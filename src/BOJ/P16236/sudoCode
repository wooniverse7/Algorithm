
    bfs를 활용해서 물고기를 먹는데 조건이 있음
    그 조건을 어떻게 충족시킬 것인가.
    1. 먹을 수 있는 물고기가 한 마리면 bfs로 최소 이동 거리로 먹음
    2. 여러 마리 라면 가장 가까운 물고기를 먹음 - bfs로 체크 가능 할 듯
    - bfs로 한 칸 씩 체크해서 거리가 가장 가까운 물고기로 상어의 좌표를 옮긴다
    3. 거리가 같다면 가장 위에 있는 물고기. 이는 좌표로 비교해서 x좌표가 가장 위에 있는 물고기로 상어의 좌표를 옮김.
            가장 위에 물고기가 여러마리라면 다시 y좌표를 비교해서 가장 왼쪽의 좌표로 상어의 좌표를 옮긴다.

    큐에는 상어의 좌표를 넣는다?
    먹은 물고기는 0으로 만든다.

    먹을 물고기가 없다면 = 방문할 곳이 없다면 리턴

bfs를 활용해서 물고기를 먹는데 조건이 있음
그 조건을 어떻게 충족시킬 것인가.
1. 먹을 수 있는 물고기가 한 마리면 bfs로 최소 이동 거리로 먹음
2. 여러 마리 라면 가장 가까운 물고기를 먹음 - bfs로 체크 가능 할 듯
  - bfs로 한 칸 씩 체크해서 거리가 가장 가까운 물고기로 상어의 좌표를 옮긴다
3. 거리가 같다면 가장 위에 있는 물고기. 이는 좌표로 비교해서 x좌표가 가장 위에 있는 물고기로 상어의 좌표를 옮김.
  가장 위에 물고기가 여러마리라면 다시 y좌표를 비교해서 가장 왼쪽의 좌표로 상어의 좌표를 옮긴다.

  큐에는 상어의 좌표를 넣는다
  먹은 물고기는 0으로 만든다.

  먹을 물고기가 없다면 = 방문할 곳이 없다면 리턴

  필요한 변수는 무엇이 있나
  카운트 변수
  상어 값 = int shark
  1. 상어의 좌표값
  3. 상어와 물고기 사이의 거리값
  2. 먹을 수 있는 물고기 중 제일 높이, 제일 왼쪽에 있는 물고기의 좌표값

  조건을 여러 개 만들어야 한다
  1. 자기보다 작은 물고기만 섭취
  2. 자기보다 큰 물고기 위로는 지나갈 수 없음
  3. 방문 처리는 필요없음. 지나갔던데 지나가도됨. 아닌가. 최단거리 구할 때는 필요할텐데. 매번 리셋이 필요한가.
    - 매번 리셋이면 400을 물고기 한 마리 먹을 때 마다 해야됨. 최대 399마리. 400x400이면 16만. 괜찮


  길라잡이
  Q. 물고기를 한 마리 먹을 때 마다 bfs를 새로 돌려야 되는가. 한 번에 다 처리가 되는가.

  시작
  일단 시작은 물고기 한 마리 먹는것부터 만들자.

  순서
  1. 상어 좌표의 값을 0으로 만들고 좌표 저장
  2. while문으로 먹을 수 있는 물고기가 없을 때 까지 반복
   2-1. 반복마다 minX, minY, dist[][] 초기화
   2-2. dist[][] 배열로 방문 체크와 함께 해당 물고기까지의 거리 저장
   2-3. minX, minY가 초기값과 같으면 먹을 수 있는 물고기가 없다는 뜻. 종료
  3. bfs로 탐색할 수 있는 곳 까지 순회
   3-1. 범위 안, 크기 제한, 방문하지 않은 곳 체크
   3-2. 만족하면 다음칸에 dist++
   3-3. 해당 좌표에 먹을 수 있는 물고기가 있으면 minX, minY, minDist와 비교해 최소값 저장
     큐가 다 빌 때 까지 순회해야함.
  4. 다음 bfs를 위한 상어 사이즈 및 좌표 수정, 먹힌 물고기 좌표 수정, 거리값 갱신을 해준다.
